/**
 * @file TQueue.h
 * @author Michael Meindl
 * @date 24.9.2016
 * @brief File containing a template class implementing a queue for communication
 */
#ifndef TQUEUE_H
#define TQUEUE_H
#include "Global.h"

class CCountingSemaphore;
class CMessage;

template<const Int32 size>
class TQueue
{
public:
	/*
	 * Method to add a message to the back of the queue.
	 * \param[in] msg 			Specifies the message which shall be pushed to the back of the queue.
	 * \param[in] waitForever	Specifies whether the thread shall be blocked until the message can be pushed.
	 * \return 					Returns true if the message was pushed successfully.
	 */
	bool pushBack(const CMessage& msg, bool waitForever);
	/*
	 * Method to add a message to the front of the queue.
	 * \param[in] msg 			Specifies the message which shall be pushed to the front of the queue.
	 * \param[in] waitForever	Specifies whether the thread shall be blocked until the message can be pushed.
	 * \return 					Returns true if the message was pushed successfully.
	 */
	bool pushFront(const CMessage& msg, bool waitForever);
	/*
	 * Method to get a message from the front of the queue.
	 * \param[out] msg 			On success the popped message will be placed in the reference instance.
	 * \param[in] waitForever 	Specifies whether the thread shall be blocked until a message can the popped.
	 * \return 					Returns true if the message was popped successfully.
	 */
	bool popFront(CMessage& msg, bool waitForever);
public:
	TQueue();
	TQueue(const TQueue<size>&) = delete;
	TQueue<size>& operator=(const TQueue<size>&) = delete;
	~TQueue() = default;
private:
	static constexpr Int32 sSize = size;
	CCountingSemaphore mReadSem;
	CCountingSemaphore mWriteSem;
	CMessage mQueue[sSize];
	Int32 mHeadIndex;
	Int32 mTailIndex;
};

#endif
