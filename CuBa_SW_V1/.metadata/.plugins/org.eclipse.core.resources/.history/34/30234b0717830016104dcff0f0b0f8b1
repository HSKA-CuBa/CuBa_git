/**
 * @file 	SCommComponent.cpp
 * @author 	Michael Meindl
 * @date	25.9.2016
 * @brief	Class definitions of SCommComponent.
 */
#include <CCommComponent.h>
#include "CDoubleBuffer.h"
#include <iostream>
#include <new>

extern CDoubleBuffer gBuffer;

void SCommComponent::init()
{
	std::cout << "[*] Comm-Component: Initializing" << std::endl;
	mProxyPtr = &(SProxy::getInstance());
}
void SCommComponent::run()
{
	std::cout << "[*] Comm-Component: Running" << std::endl;

	CContainer::CPhiValues phiValues;
	CContainer::CPhi__dValues phi__dValues;
	CContainer::CPsi__dValues psi__dValues;
	while(true)
	{
		if(gBuffer.getData(true, phiValues, phi__dValues, psi__dValues))
		{
			std::cout << "[*] Comm-Component: Received values" << std::endl;
			std::cout << " Phi-Raw: " << phiValues.mRaw <<
					" Phi-Comp: " << phiValues.mComp <<
					" Phi-Kalman: " << phiValues.mKalman << std::endl;
		}
	}
}
static UInt8 sMemory[cMakeAlignmentSize(sizeof(SCommComponent))] = {0U};
SCommComponent* SCommComponent::sInstance = nullptr;
CMutex SCommComponent::sAcessMutex(true, true);
SCommComponent::SCommComponent() : mProxyPtr(nullptr)
{

}
SCommComponent& SCommComponent::getInstance()
{
	sAcessMutex.take(true);
	if(nullptr == sInstance)
	{
		sInstance = reinterpret_cast<SCommComponent*>(new(sMemory)SCommComponent);
	}
	sAcessMutex.give();
	return *sInstance;
}
